
.. _program_listing_file__home_runner_work_spdl_spdl_src_libspdl_core_generator.h:

Program Listing for File generator.h
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_spdl_spdl_src_libspdl_core_generator.h>` (``/home/runner/work/spdl/spdl/src/libspdl/core/generator.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (c) Meta Platforms, Inc. and affiliates.
    * All rights reserved.
    *
    * This source code is licensed under the BSD-style license found in the
    * LICENSE file in the root directory of this source tree.
    */
   
   #pragma once
   
   #include <coroutine>
   #include <exception>
   
   namespace spdl::core {
   
   template <typename T>
   struct Generator {
     struct promise_type;
     using handle_type = std::coroutine_handle<promise_type>;
   
     struct promise_type {
       T value;
       std::exception_ptr exception;
       Generator get_return_object() {
         return Generator(handle_type::from_promise(*this));
       }
       std::suspend_always initial_suspend() {
         return {};
       }
       std::suspend_always final_suspend() noexcept {
         return {};
       }
       void unhandled_exception() {
         exception = std::current_exception();
       }
       template <std::convertible_to<T> From>
       std::suspend_always yield_value(From&& from) {
         value = std::forward<From>(from);
         return {};
       }
       void return_void() {}
     };
   
     handle_type h_;
   
     explicit Generator(handle_type h) : h_(h) {}
     Generator(const Generator&) = delete;
     Generator& operator=(const Generator&) = delete;
     Generator(Generator&&) = default;
     Generator& operator=(Generator&&) = default;
     ~Generator() {
       h_.destroy();
     }
     explicit operator bool() {
       fill();
       return !h_.done();
     }
     T operator()() {
       fill();
       full = false;
       return std::move(h_.promise().value);
     }
   
    private:
     bool full = false;
   
     void fill() {
       if (!full) {
         h_();
         if (h_.promise().exception) {
           std::rethrow_exception(h_.promise().exception);
         }
         full = true;
       }
     }
   };
   } // namespace spdl::core
