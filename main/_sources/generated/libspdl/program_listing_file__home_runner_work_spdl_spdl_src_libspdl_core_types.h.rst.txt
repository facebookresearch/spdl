
.. _program_listing_file__home_runner_work_spdl_spdl_src_libspdl_core_types.h:

Program Listing for File types.h
================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_spdl_spdl_src_libspdl_core_types.h>` (``/home/runner/work/spdl/spdl/src/libspdl/core/types.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (c) Meta Platforms, Inc. and affiliates.
    * All rights reserved.
    *
    * This source code is licensed under the BSD-style license found in the
    * LICENSE file in the root directory of this source tree.
    */
   
   #pragma once
   
   #include <cstdint>
   #include <map>
   #include <optional>
   #include <stdexcept>
   #include <string>
   
   #define SPDL_DEFAULT_BUFFER_SIZE 8096
   
   extern "C" {
   #if __has_include(<libavutil/rational.h>)
   #include <libavutil/rational.h>
   #else
   // Copying the definition of AVRAtional.
   // It's unlikely they change, but if it should ever happen, it could cause SEGV.
   // https://www.ffmpeg.org/doxygen/4.4/rational_8h_source.html#l00058
   // https://www.ffmpeg.org/doxygen/5.1/rational_8h_source.html#l00058
   // https://www.ffmpeg.org/doxygen/6.1/rational_8h_source.html#l00058
   // https://www.ffmpeg.org/doxygen/7.0/rational_8h_source.html#l00058
   typedef struct AVRational {
     int num; 
     int den; 
   } AVRational;
   #endif
   }
   
   namespace spdl::core {
   
   using OptionDict = std::map<std::string, std::string>;
   
   using Rational = AVRational;
   
   using TimeWindow = std::tuple<Rational, Rational>;
   
   enum class MediaType {
     Audio, 
     Video, 
     Image 
   };
   
   struct DemuxConfig {
     std::optional<std::string> format = std::nullopt;
     std::optional<OptionDict> format_options = std::nullopt;
     int buffer_size = SPDL_DEFAULT_BUFFER_SIZE;
   };
   
   struct DecodeConfig {
     std::optional<std::string> decoder = std::nullopt;
     std::optional<OptionDict> decoder_options = std::nullopt;
   };
   
   enum class ElemClass {
     Int, 
     UInt, 
     Float 
   };
   
   enum class CodecID {
     MPEG1VIDEO, 
     MPEG2VIDEO, 
     MPEG4, 
     WMV3, 
     VC1, 
     H264, 
     HEVC, 
     VP8, 
     VP9, 
     MJPEG, 
     AV1 
   };
   
   template <MediaType media>
   struct EncodeConfigBase;
   
   template <>
   struct EncodeConfigBase<MediaType::Video> {
     int height;
     int width;
   
     // Optional overrides
     const std::optional<std::string> pix_fmt = std::nullopt;
     const std::optional<Rational> frame_rate = std::nullopt;
   
     int bit_rate = -1;
     int compression_level = -1;
   
     // qscale corresponds to ffmpeg CLI's qscale.
     // Example: MP3
     // https://trac.ffmpeg.org/wiki/Encode/MP3
     // This should be set like
     // https://github.com/FFmpeg/FFmpeg/blob/n4.3.2/fftools/ffmpeg_opt.c#L1550
     int qscale = -1;
   
     int gop_size = -1;
     int max_b_frames = -1;
   
     std::optional<std::string> colorspace;
     std::optional<std::string> color_primaries;
     std::optional<std::string> color_trc;
   };
   
   template <>
   struct EncodeConfigBase<MediaType::Audio> {
     int num_channels;
   
     // Optional overrides
     const std::optional<std::string> sample_fmt = std::nullopt;
     const std::optional<int> sample_rate = std::nullopt;
   
     int bit_rate = -1;
     int compression_level = -1;
   
     // qscale corresponds to ffmpeg CLI's qscale.
     // Example: MP3
     // https://trac.ffmpeg.org/wiki/Encode/MP3
     // This should be set like
     // https://github.com/FFmpeg/FFmpeg/blob/n4.3.2/fftools/ffmpeg_opt.c#L1550
     int qscale = -1;
   };
   
   using VideoEncodeConfig = EncodeConfigBase<MediaType::Video>;
   using AudioEncodeConfig = EncodeConfigBase<MediaType::Audio>;
   
   class InternalError : public std::logic_error {
     using std::logic_error::logic_error;
   };
   
   } // namespace spdl::core
