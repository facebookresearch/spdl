# Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree.
#
# pyre-ignore-all-errors
#
# @generated
# This file is generated by stubgen.py
# and should not be edited manually.
# Use spdl/io/lib/stubgen.py to generate stubs.


from collections.abc import Callable, Sequence
from typing import Annotated, overload

from numpy.typing import ArrayLike

import spdl.io.lib._libspdl


class CUDAConfig:
    """
    Specify the CUDA device and memory management.

    See the factory function :py:func:`~spdl.io.cuda_config`.
    """

def cuda_config(device_index: int, stream: int = 2, allocator: tuple[Callable[[int, int, int], int], Callable[[int], None]] | None = None) -> CUDAConfig: ...

class CUDABuffer:
    """
    CUDABuffer implements CUDA array interface.

    To be passed to casting functions like :py:func:`~spdl.io.to_torch` and
    :py:func:`~spdl.io.to_numba`.
    """

    @property
    def __cuda_array_interface__(self) -> dict:
        """
        See https://numba.pydata.org/numba-doc/latest/cuda/cuda_array_interface.html.
        """

    @property
    def device_index(self) -> int:
        """The device index."""

class NvDecDecoder:
    """
    Decods video packets using NVDEC hardware acceleration.

    Use :py:func:`nvdec_decoder` to instantiate.

    To decode videos with NVDEC, you provide the decoder configuration
    and codec information directly to :py:func:`nvdec_decoder`, then feed
    video packets. Finally, call flush to let the decoder know that it
    reached the end of the video stream, so that the decoder flushes its
    internally buffered frames.

    .. note::

       To decode H264 and HEVC videos, the packets must be Annex B
       format. You can convert video packets to Annex B format by
       applying bit stream filter while demuxing or after demuxing.
       See the examples bellow.

    .. seealso::

       - :py:func:`decode_packets_nvdec`: Decode video packets using
         NVDEC.
       - :py:func:`streaming_load_video_nvdec`: Decode video frames
         from source in streaming fashion.
       - :py:mod:`streaming_nvdec_decoding`: Demonstrates how to
         decode a long video using NVDEC.

    .. admonition:: Example - decoding the whole video

       .. code-block::

          cuda_config = spdl.io.cuda_config(device_index=0)

          packets = spdl.io.demux_video(src)
          # Convert to Annex B format
          if (c := packets.codec.name) in ("h264", "hevc"):
              packets = spdl.io.apply_bsf(f"{c}_mp4toannexb")

          # Initialize the decoder
          decoder = nvdec_decoder(cuda_config, packets.codec)

          # Decode packets
          frames = decoder.decode(packets)

          # Done
          frames += decoder.flush()

          # Convert (and batch) the NV12 frames into RGB
          frames = spdl.io.nv12_to_rgb(frames)

    .. admonition:: Example - incremental decoding

       .. code-block::

          cuda_config = spdl.io.cuda_config(device_index=0)

          demuxer = spdl.io.Demuxer(src)
          codec = demuxer.video_codec

          match codec.name:
              case "h264" | "hevc":
                  bsf = f"{codec.name}_mp4toannexb"
              case _:
                  bsf = None

          # Initialize the decoder
          decoder = nvdec_decoder(cuda_config, codec)

          for packets in demuxer.streaming_demux_video(10, bsf=bsf):
              buffer = decoder.decode(packets)
              buffer = spdl.io.nv12_to_rgb(buffer)
              # Process buffer here

          buffer = decoder.flush()
          buffer = spdl.io.nv12_to_rgb(buffer)
    """

    def init(self, device_config: CUDAConfig, codec: spdl.io.lib._libspdl.VideoCodec, *, crop_left: int = 0, crop_top: int = 0, crop_right: int = 0, crop_bottom: int = 0, scale_width: int = -1, scale_height: int = -1) -> None:
        """
        Initialize the decoder.

        .. deprecated:: 0.1.7

           This method was merged with :py:func:`nvdec_decoder()`.
           Pass these parameters directly to initialize the decoder.
           The old pattern of calling ``decoder.init()`` after ``nvdec_decoder()``
           will be removed in a future version.

        .. note::

           Creation of underlying decoder object is expensive.
           Typically, it takes about 300ms or more.

           To mitigate this the implementation tries to reuse the decoder.
           This works if the new video uses the same codecs as
           the previous one, and the difference is limited to the
           resolution of the video.

           If you are processing videos of different codecs, then the
           decoder has to be re-created.

        Args:
            cuda_config: The device configuration. Specifies the GPU of which
                video decoder chip is used, the CUDA memory allocator and
                CUDA stream used to fetch the result from the decoder engine.

            codec: The information of the source video.

            crop_left, crop_top, crop_right, crop_bottom (int):
                *Optional:* Crop the given number of pixels from each side.

            scale_width, scale_height (int): *Optional:* Resize the frame.
                Resizing is applied after cropping.
        """

    def decode(self, packets: spdl.io.lib._libspdl.VideoPackets) -> list[CUDABuffer]:
        """
        Decode video frames from the give packets.

        .. note::

           Due to how video codec works, the number of returned frames
           do not necessarily match the number of packets provided.

           The method can return less number of frames or more number of
           frames.

        Args:
            packets: Video packets.

        Returns:
            The decoded frames.
        """

    def flush(self) -> list[CUDABuffer]:
        """
        Notify the decoder the end of video stream, and fetch buffered frames.

        Returns:
            The decoded frames. (can be empty)
        """

    def decode_all(self, packets: spdl.io.lib._libspdl.VideoPackets) -> CUDABuffer:
        """
        Decode all packets and return NV12 buffer.

        This method decodes all packets and flushes the decoder in one operation,
        and returns the resulting frames as one contiguous memory buffer.

        Args:
            packets: Video packets to decode.

        Returns:
            A :py:class:`~spdl.io.CUDABuffer` containing NV12 frames with shape
            ``[num_frames, h*1.5, width]``, where ``num_frames`` reflects
            the actual number of decoded frames, which should match
            the number of packets.
        """

@overload
def decode_image_nvjpeg(data: bytes, *, device_config: CUDAConfig, scale_width: int = -1, scale_height: int = -1, pix_fmt: str = 'rgb', sync: bool = True, _zero_clear: bool = False) -> CUDABuffer: ...

@overload
def decode_image_nvjpeg(data: Sequence[bytes], *, device_config: CUDAConfig, scale_width: int, scale_height: int, pix_fmt: str = 'rgb', sync: bool = True, _zero_clear: bool = False) -> CUDABuffer: ...

def cpu_storage(size: int) -> spdl.io.lib._libspdl.CPUStorage: ...

@overload
def transfer_buffer(buffer: spdl.io.lib._libspdl.CPUBuffer, *, device_config: CUDAConfig) -> CUDABuffer: ...

@overload
def transfer_buffer(buffer: Annotated[ArrayLike, dict(order='C', device='cpu')], *, device_config: CUDAConfig) -> CUDABuffer: ...

def transfer_buffer_cpu(buffer: Annotated[ArrayLike, dict(order='C', device='cuda')]) -> spdl.io.lib._libspdl.CPUBuffer: ...

def init() -> None: ...

def built_with_cuda() -> bool: ...

def built_with_nvcodec() -> bool: ...

def built_with_nvjpeg() -> bool: ...

def synchronize_stream(arg: CUDAConfig, /) -> None: ...

def nv12_to_planar_rgb(buffers: Sequence[CUDABuffer], *, device_config: CUDAConfig, matrix_coeff: int = 1, sync: bool = True) -> CUDABuffer: ...

def nv12_to_planar_bgr(buffers: Sequence[CUDABuffer], *, device_config: CUDAConfig, matrix_coeff: int = 1, sync: bool = True) -> CUDABuffer: ...

def nv12_to_planar_rgb_batched(nv12_batch: CUDABuffer, num_frames: int, *, device_config: CUDAConfig, matrix_coeff: int = 1, sync: bool = True) -> CUDABuffer:
    """
    Convert batched NV12 frames to planar RGB.

    Args:
        nv12_batch: 3D buffer with shape ``[num_frames, height*1.5, width]``.
        num_frames: Actual number of frames to convert (may be ``<= max_frames``).
        device_config: The CUDA device configuration.
        matrix_coeff: Color matrix coefficients for conversion (default: ``BT.709``).
        sync: If ``True``, synchronizes the stream before returning.

    Returns:
        CUDA buffer containing planar RGB data with shape ``[num_frames, 3, height, width]``.
    """

def nv12_to_planar_bgr_batched(nv12_batch: CUDABuffer, num_frames: int, *, device_config: CUDAConfig, matrix_coeff: int = 1, sync: bool = True) -> CUDABuffer:
    """
    Convert batched NV12 frames to planar BGR.

    Args:
        nv12_batch: 3D buffer with shape ``[num_frames, height*1.5, width]``.
        num_frames: Actual number of frames to convert (may be ``<= max_frames``).
        device_config: The CUDA device configuration.
        matrix_coeff: Color matrix coefficients for conversion (default: ``BT.709``).
        sync: If ``True``, synchronizes the stream before returning.

    Returns:
        CUDA buffer containing planar BGR data with shape ``[num_frames, 3, height, width]``.
    """
