# Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree.

__all__ = [
    "load_npy",
    "load_npz",
    "NpzFile",
]
from collections.abc import Iterator, Mapping

import numpy as np
from numpy.typing import NDArray

# Importing `spdl.io.lib` instead of `spdl.io.lilb._archive`
# so as to delay the import of C++ extension module
from . import lib as _libspdl

# pyre-strict


def _get_pointer(data: bytes) -> int:
    return np.frombuffer(data, dtype=np.byte).ctypes.data


def load_npy(
    data: bytes | bytearray | memoryview,  # pyre-ignore
    *,
    copy: bool = False,
) -> NDArray:
    """Load NumPy NDArray from bytes.

    This function loads NumPy NDArray from memory. It is equivalent to
    ``numpy.load(io.BytesIO(data))``, but it is more efficient.

    .. note::

       This function does not support ``object`` dtype, and Fortran order.

    Example:

        >>> ref = np.arange(20)
        >>> buffer = BytesIO()
        >>> np.save(buffer, ref)
        >>> buffer.seek(0)
        >>> data = buffer.getvalue()
        >>> restore = spdl.io.load_npy(data)
        >>> assert np.array_equal(restore, ref)

    Args:
        data: The data generated by :py:func:`numpy.save` function.
            (Note that it is different from :py:meth:`numpy.ndarray.tobytes`,
            which does not contain shape and dtype.)
        copy: Whether to copy data. Default: no copy.

    Returns:
        The restored array data.

    .. seealso::

       - :py:mod:`numpy.lib.format`: The detail of NPY serialization is found.

       - `_read_array_header <https://github.com/numpy/numpy/blob/v2.2.0/numpy/lib/format.py#L604>`_:
         The function called by :py:func:`numpy.load` to parse the header.
       - `_read_array <https://github.com/numpy/numpy/blob/v2.2.0/numpy/lib/format.py#L762>`_:
         The function called by :py:func:`numpy.load` when loading the data region of NPY file.

    .. note::

       There is a branch in
       `_read_array <https://github.com/numpy/numpy/blob/v2.2.0/numpy/lib/format.py#L827-L854>`_
       function where the execution can call some faster implementation.
       However, :py:class:`~io.BytesIO` does not meet the condition.
       (:py:func:`~numpy.lib.format.isfileobj` function returns ``False`` for :py:class:`io.BytesIO`.
       [`source <https://github.com/numpy/numpy/blob/v2.2.0/numpy/lib/format.py#L999>`_])
       Even if the execution takes the faster :py:func:`numpy.fromfile` path, it
       `creates a new array <https://github.com/numpy/numpy/blob/v2.2.0/numpy/_core/records.py#L935-L939>`_.

    """
    buffer = _libspdl._archive.load_npy(_get_pointer(data), len(data))
    return np.array(buffer, copy=copy)


class NpzFile(Mapping):
    """NpzFile()
    A class mimics the behavior of :py:class:`numpy.lib.npyio.NpzFile`.

    It is a thin wrapper around a zip archive, and implements
    :py:class:`collections.abc.Mapping` interface.

    See :py:func:`load_npz` for the usage.
    """

    def __init__(self, data: bytes, meta: dict[str, tuple[int, int, int, int]]) -> None:
        self._data: int = _get_pointer(data)
        self._len: int = len(data)
        self._meta = meta
        self.files: list[str] = [f.removesuffix(".npy") for f in meta]

    def __iter__(self) -> Iterator[str]:
        return iter(self.files)

    def __len__(self) -> int:
        return len(self.files)

    def __getitem__(self, key: str) -> NDArray:
        """Provide dictionary-like access to array data.

        One difference from the regular dictionary access is that
        it also supports accessing the item without ``.npy`` suffix
        in the key. This matches the behavior of :py:class:`numpy.lib.npyio.NpzFile`.
        """
        if key in self._meta:
            pass
        elif key in self.files:
            key = f"{key}.npy"
        else:
            raise KeyError(f"{key} is not a file in the archive")

        offset, compressed_size, uncompressed_size, compression_method = self._meta[key]
        match compression_method:
            case 0:
                buffer = _libspdl._archive.load_npy(
                    self._data, size=compressed_size, offset=offset
                )
                return np.array(buffer, copy=False)
            case 8:
                buffer = _libspdl._archive.load_npy_compressed(
                    self._data, offset, compressed_size, uncompressed_size
                )
                return np.array(buffer, copy=False)
            case _:
                raise ValueError(
                    "Compression method other than DEFLATE is not supported."
                )

    def __contains__(self, key: str) -> bool:
        return key in self._meta or key in self.files

    def __repr__(self) -> str:
        return f"NpzFile object with {len(self)} entries."


def load_npz(data: bytes) -> NpzFile:
    """**[Experimental]** Load a numpy archive file (``npz``).

    It is almost a drop-in replacement for :py:func:`numpy.load` function,
    but it only supports the basic use cases.

    This function uses the C++ implementation of the zip archive reader, which
    releases the GIL. So it is more efficient than the official NumPy implementation
    for supported cases.

    Args:
        data: The data to load.

    Example

       >>> x = np.arange(10)
       >>> y = np.sin(x)
       >>>
       >>> with tempfile.TemporaryFile() as f:
       ...     np.savez(f, x=x, y=y)
       ...     f.seek(0)
       ...     data = spdl.io.load_npz(f.read())
       ...
       >>> assert np.array_equal(data["x"], x)
       >>> assert np.array_equal(data["y"], y)

    """
    meta = {val[0]: val[1:] for val in _libspdl._archive.parse_zip(data)}
    return NpzFile(data, meta)
