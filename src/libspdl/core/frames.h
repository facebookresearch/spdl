/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <libspdl/core/buffer.h>
#include <libspdl/core/types.h>

#include <memory>
#include <vector>

struct AVFrame;

namespace spdl::core {

////////////////////////////////////////////////////////////////////////////////
// FFmpeg Frames
////////////////////////////////////////////////////////////////////////////////

template <MediaType media_type>
class Frames;

using AudioFrames = Frames<MediaType::Audio>;
using VideoFrames = Frames<MediaType::Video>;
using ImageFrames = Frames<MediaType::Image>;

template <MediaType media_type>
using FramesPtr = std::unique_ptr<Frames<media_type>>;

using AudioFramesPtr = FramesPtr<MediaType::Audio>;
using VideoFramesPtr = FramesPtr<MediaType::Video>;
using ImageFramesPtr = FramesPtr<MediaType::Image>;

#define _IS_AUDIO (media_type == MediaType::Audio)
#define _IS_VIDEO (media_type == MediaType::Video)
#define _IS_IMAGE (media_type == MediaType::Image)

///
/// Base class that holds media frames decoded with FFmpeg.
template <MediaType media_type>
class Frames {
 private:
  ///
  /// Used for tracking the lifetime in tracing.
  uint64_t id{0};

  /// Time base of the frames
  Rational time_base;

 private:
  /// Series of decoded frames generated by FFmpeg.
  /// If media type is image, there will be exactly one ``AVFrame`` instance.
  /// If media type is video, there will be multiple of ``AVFrame`` instances
  /// and each of which represents one frame of video. If media type is audio,
  /// there will be multiple of ``AVFrame`` instances and each contains multiple
  /// audio samples.
  ///
  /// We deal with multiple frames at a time, so we use vector of raw
  /// pointers with dedicated destructor, as opposed to vector of managed
  /// pointers
  std::vector<AVFrame*> frames{};

 public:
  Frames(uint64_t id, Rational time_base);

  ///
  /// No copy constructor
  Frames(const Frames&) = delete;
  ///
  /// No copy assignment operator
  Frames& operator=(const Frames&) = delete;
  ///
  /// Move constructor
  Frames(Frames&&) noexcept;
  ///
  /// Move assignment operator
  Frames& operator=(Frames&&) noexcept;
  ///
  /// Destructor releases ``AVFrame`` resources
  ~Frames();

  ///
  /// Get the ID used for tracing.
  uint64_t get_id() const;

  ///
  /// Get the list of frames.
  const std::vector<AVFrame*>& get_frames() const;

  //////////////////////////////////////////////////////////////////////////////
  // Common
  //////////////////////////////////////////////////////////////////////////////

  ///
  /// Get the format of the frames.
  const char* get_media_format_name() const;

  ///
  /// Get metadata
  OptionDict get_metadata() const;

  ///
  /// Get the number of frames.
  int get_num_frames() const;
  // the behavior is different for audio

  ///
  /// Get the time_base, which is the unit of time that this Frame uses.
  Rational get_time_base() const;

  ///
  /// Push a new frame into the container.
  void push_back(AVFrame* frame);
  // the behavior is different for image

  // Get the PTS of the specified frame.
  // throws if the index is not within the range
  int64_t get_pts(size_t index = 0) const;

  FramesPtr<media_type> clone() const;

  //////////////////////////////////////////////////////////////////////////////
  // Audio specific
  //////////////////////////////////////////////////////////////////////////////

  ///
  /// Get the sample rate
  int get_sample_rate() const
    requires _IS_AUDIO;

  ///
  /// Get the number of audio channels.
  int get_num_channels() const
    requires _IS_AUDIO;

  //////////////////////////////////////////////////////////////////////////////
  // Common to Image/Video
  //////////////////////////////////////////////////////////////////////////////

  /// Get the number of planes in the image.
  ///
  /// Note: The number of planes and the number of color channels do not match.
  /// For example, NV12 has 3 channels, YUV, but U and V are interleaved in the
  /// same plane.
  int get_num_planes() const
    requires(_IS_IMAGE || _IS_VIDEO);

  ///
  /// Get the width of the image.
  int get_width() const
    requires(_IS_IMAGE || _IS_VIDEO);

  ///
  /// Get the height of the image.
  int get_height() const
    requires(_IS_IMAGE || _IS_VIDEO);

  //////////////////////////////////////////////////////////////////////////////
  // Video specific
  //////////////////////////////////////////////////////////////////////////////

  ///
  /// Range slice operation, using Python's slice notation.
  VideoFramesPtr slice(int start, int stop, int step) const
    requires _IS_VIDEO;

  ///
  /// Slice (`__getitem__`) operation.
  VideoFramesPtr slice(const std::vector<int64_t>& index) const
    requires _IS_VIDEO;

  ///
  /// Slice (`__getitem__`) operation.
  ImageFramesPtr slice(int64_t index) const
    requires _IS_VIDEO;
};

template <MediaType media_type>
FramesPtr<media_type> clone(const Frames<media_type>& src);

#undef _IS_AUDIO
#undef _IS_VIDEO
#undef _IS_IMAGE

} // namespace spdl::core
