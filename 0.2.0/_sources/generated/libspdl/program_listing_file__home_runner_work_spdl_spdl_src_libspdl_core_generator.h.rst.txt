
.. _program_listing_file__home_runner_work_spdl_spdl_src_libspdl_core_generator.h:

Program Listing for File generator.h
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_spdl_spdl_src_libspdl_core_generator.h>` (``/home/runner/work/spdl/spdl/src/libspdl/core/generator.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (c) Meta Platforms, Inc. and affiliates.
    * All rights reserved.
    *
    * This source code is licensed under the BSD-style license found in the
    * LICENSE file in the root directory of this source tree.
    */
   
   #pragma once
   
   #include <coroutine>
   #include <exception>
   #include <iterator>
   #include <stdexcept>
   #include <utility>
   
   namespace spdl::core {
   
   template <typename T>
   struct Generator {
     struct promise_type;
     using handle_type = std::coroutine_handle<promise_type>;
   
     struct promise_type {
       T value;
       std::exception_ptr exception;
       bool full = false;
   
       Generator get_return_object() {
         return Generator(handle_type::from_promise(*this));
       }
   
       std::suspend_always initial_suspend() {
         return {};
       }
   
       std::suspend_always final_suspend() noexcept {
         return {};
       }
   
       void unhandled_exception() {
         exception = std::current_exception();
       }
   
       template <std::convertible_to<T> From>
       std::suspend_always yield_value(From&& from) {
         value = std::forward<From>(from);
         return {};
       }
   
       void return_void() {}
     };
   
     struct iterator {
       using iterator_category = std::input_iterator_tag;
       using difference_type = std::ptrdiff_t;
       using value_type = T;
       using pointer = T*;
       using reference = T&;
   
       handle_type h_;
   
       iterator& operator++() {
         h_();
         if (h_.promise().exception) {
           std::rethrow_exception(h_.promise().exception);
         }
         return *this;
       }
   
       T& operator*() const {
         return h_.promise().value;
       }
   
       bool operator==(std::default_sentinel_t) const {
         return !h_ || h_.done();
       }
     };
   
     handle_type h_;
   
     explicit Generator(handle_type h) : h_(h) {}
   
     Generator(const Generator&) = delete;
   
     Generator& operator=(const Generator&) = delete;
   
     Generator(Generator&& other) noexcept
         : h_(std::exchange(other.h_, nullptr)) {}
   
     Generator& operator=(Generator&& other) noexcept {
       if (this != &other) {
         if (h_) {
           h_.destroy();
         }
         h_ = std::exchange(other.h_, nullptr);
       }
       return *this;
     }
   
     ~Generator() {
       if (h_) {
         h_.destroy();
       }
     }
   
     iterator begin() {
       if (h_) {
         h_();
         if (h_.promise().exception) {
           std::rethrow_exception(h_.promise().exception);
         }
       }
       return iterator{h_};
     }
   
     std::default_sentinel_t end() {
       return {};
     }
   
     explicit operator bool() {
       if (!h_) {
         return false;
       }
       fill();
       return !h_.done();
     }
   
     T operator()() {
       if (!h_) {
         throw std::runtime_error("Generator has been moved from");
       }
       fill();
       h_.promise().full = false;
       return std::move(h_.promise().value);
     }
   
    private:
     void fill() {
       if (!h_.promise().full) {
         h_();
         if (h_.promise().exception) {
           std::rethrow_exception(h_.promise().exception);
         }
         h_.promise().full = true;
       }
     }
   };
   } // namespace spdl::core
